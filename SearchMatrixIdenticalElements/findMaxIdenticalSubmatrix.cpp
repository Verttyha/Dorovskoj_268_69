#include "functions.h"
#include "errors.h"
#include <vector>
/**
 * @brief Находит наибольшую прямоугольную подматрицу, заполненную одинаковыми значениями.
 *
 * Последовательно проверяет все возможные прямоугольные подматрицы, начиная от каждой позиции (i, j).
 * Сравнивает каждый элемент с эталонным значением — значением в (i, j).
 *
 * @param matrix Матрица целых чисел.
 * @return Rectangle Прямоугольник с координатами и площадью максимальной однородной подматрицы.
 * @throws Error если матрица некорректна.
 */

Rectangle findMaxIdenticalSubmatrix(const std::vector<std::vector<int>>& matrix) {
    int n = static_cast<int>(matrix.size());  ///< Количество строк в матрице.
    if (n == 0) {
        return { 0, 0, 0, 0, 0 }; ///< Возврат пустого прямоугольника при пустой матрице.
    }
    int m = static_cast<int>(matrix[0].size());  ///< Количество столбцов в первой строке.
    if (m == 0) {
        return { 0, 0, 0, 0, 0 }; ///< Возврат пустого прямоугольника при нулевой ширине.
    }

    Rectangle maxRect = { 0, 0, 0, 0, 1 };  ///< Инициализация максимального прямоугольника минимальной площадью.

    for (int i = 0; i < n; ++i) {  ///< Проход по строкам.
        for (int j = 0; j < m; ++j) {  ///< Проход по столбцам.
            int current = matrix[i][j];  ///< Эталонное значение текущей ячейки.

            // Вычисляем максимальную ширину вправо от (i, j), где элементы равны current.
            int right = j;
            while (right < m && matrix[i][right] == current) {
                ++right;
            }
            int max_width = right - j;  ///< Максимальная ширина однородного участка.

            // Перебор всех возможных ширин от 1 до max_width.
            for (int w = 1; w <= max_width; ++w) {
                int down = i;         ///< Нижняя граница текущей подматрицы.
                bool valid = true;    ///< Флаг валидности текущей подматрицы.

                // Расширяем подматрицу вниз, проверяя совпадение всех элементов.
                while (down < n && valid) {
                    for (int k = j; k < j + w; ++k) {
                        if (matrix[down][k] != current) {
                            valid = false;  ///< Нарушение однородности.
                            break;
                        }
                    }
                    if (valid) {
                        ++down;  ///< Увеличиваем высоту, если строка валидна.
                    }
                }

                int rows = down - i;           ///< Количество строк в найденной подматрице.
                int area = rows * w;           ///< Площадь текущей подматрицы.
                if (area > maxRect.size) {     ///< Обновление максимальной подматрицы.
                    maxRect = { i, j, down - 1, j + w - 1, area };
                }
            }
        }
    }

    return maxRect;  ///< Возврат прямоугольника с максимальной площадью.
}